name: Integration Tests

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main

permissions:
  contents: write

jobs:
  test:
    runs-on: ubuntu-latest
    env:
      RUST_BACKTRACE: full
      RUST_LOG: debug

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Cargo registry + build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-export-modules-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config libssl-dev protobuf-compiler

      - name: Build module for l402
        run: cargo build --release --features export-modules

      - name: Set up Docker Compose
        env:
          ROOT_KEY: ABDEGHKLMPTC
          CURRENCY: USD
          AMOUNT: 0.01
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose -f docker-compose.yml up -d bitcoind

      - name: Create env file
        run: |
          touch .env
          echo ROOT_KEY=ABDEGHKLMPTC >> .env
          cat .env

      - name: Start LNURL service
        env:
          LNURL_ADDRESS: hello@getalby.com
        run: |
          echo "Starting nginx-lnurl and grpc-content-server..."
          docker-compose -f docker-compose.yml up -d nginx-lnurl grpc-content-server

      - name: Run Integration Tests - LNURL
        run: |
          docker logs nginx-lnurl
          echo "Testing with LNURL configuration..."
          sleep 15

          # Test free route
          echo "Testing free route..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Free route returned status $status_code, expected 200"
            docker logs nginx-lnurl
            exit 1
          fi

          # Test protected route without header
          echo "Testing protected route without header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-lnurl
            exit 1
          fi

          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi

          # Flush Redis to clear any previously stored preimages (replay protection)
          echo "Flushing Redis for clean test state..."
          echo "Keys before flush:"
          docker exec redis redis-cli keys "l402:*"
          docker exec redis redis-cli flushall
          echo "Keys after flush:"
          docker exec redis redis-cli keys "l402:*"
          docker exec redis redis-cli dbsize
          
          # Wait a moment for flush to propagate
          sleep 2
          
          # Test with valid L402 credentials
          echo "Testing with valid L402 credentials..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Protected route with valid L402 returned status $status_code, expected 200"
            docker logs nginx-lnurl
            exit 1
          fi

          # Test with invalid preimage
          echo "Testing with invalid preimage..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:fbe9ac25c04e14b10177514e2d57b0e39224e70277ac1a2cd23c28e58cd4ea35" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with invalid preimage returned status $status_code, expected 401"
            docker logs nginx-lnurl
            exit 1
          fi

          # Test with macaroon without caveats
          echo "Testing with macaroon without caveats..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 AgEETFNBVALmAUr/gQMBARJNYWNhcm9vbklkZW50aWZpZXIB/4IAAQMBB1ZlcnNpb24BBgABC1BheW1lbnRIYXNoAf+EAAEHVG9rZW5JZAH/hgAAABT/gwEBAQRIYXNoAf+EAAEGAUAAABn/hQEBAQlbMzJddWludDgB/4YAAQYBQAAAa/+CAiD/pv/jOjY1/9oC/4z/tHb/qf/2Jf+d/4H/u/+YGHj/+/+O/8D/v/+P/8X/qRL/5v/x/4r/tkIBIA1Y/8j/pR3/0P+b/7cwWP+W/87/sD18GP//Hf/f/9Aj//NcBFs2/9VhNEUF/70AAAAGIDlR1jVm5IfEJgvuSQoJLqLg4FcW4Ib1vW8sbkRHdUWX:651505fae9ea341c770c6ebef207d8560d546eb3aee26985e584c15d1c987875" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with macaroon without caveats returned status $status_code, expected 401"
            docker logs nginx-lnurl
            exit 1
          fi

          echo "Testing Multi-tenant LNURL Lightning invoice generation..."

          # Test tenant1 route - should generate invoice to hello@getalby.com
          echo "Testing tenant1 route..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/tenant1)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Tenant1 route returned status $status_code, expected 402"
            docker logs nginx-lnurl
            exit 1
          fi

          # Check if WWW-Authenticate header is present for tenant1
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing for tenant1"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi

          # Extract invoice from tenant1 response
          invoice_tenant1=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice_tenant1" ]; then
            echo "Error: No invoice found for tenant1"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi
          echo "✅ Tenant1 returned L402 challenge with invoice: ${invoice_tenant1:0:50}..."

          echo "✅ Multi-tenant LNURL Lightning integration tests completed!"

      - name: Run Integration Tests - gRPC
        run: |
          docker logs grpc-content-server
          echo "Testing gRPC server..."
          sleep 5

          # Install grpcurl for testing gRPC endpoints
          echo "Installing grpcurl..."
          curl -L https://github.com/fullstorydev/grpcurl/releases/download/v1.8.9/grpcurl_1.8.9_linux_x86_64.tar.gz | tar -xzf - -C /tmp
          sudo mv /tmp/grpcurl /usr/local/bin/

          # Test gRPC service reflection
          echo "Testing gRPC service reflection..."
          grpcurl -plaintext localhost:50051 list || {
            echo "Error: gRPC reflection failed"
            docker logs grpc-content-server
            exit 1
          }

          # Test GetContent method
          echo "Testing GetContent method..."
          response=$(grpcurl -plaintext -d '{"path": "/test.txt"}' localhost:50051 content.ContentService/GetContent)
          if ! echo "$response" | grep -q "Content for path"; then
            echo "Error: GetContent method failed"
            echo "Response: $response"
            docker logs grpc-content-server
            exit 1
          fi

          # Test GetProtectedContent method
          echo "Testing GetProtectedContent method..."
          response=$(grpcurl -plaintext -d '{"path": "/protected"}' localhost:50051 content.ContentService/GetProtectedContent)
          if ! echo "$response" | grep -q "This is Protected Content"; then
            echo "Error: GetProtectedContent method failed"
            echo "Response: $response"
            docker logs grpc-content-server
            exit 1
          fi

          # Test GetFreeContent method
          echo "Testing GetFreeContent method..."
          response=$(grpcurl -plaintext -d '{"path": "/free"}' localhost:50051 content.ContentService/GetFreeContent)
          if ! echo "$response" | grep -q "Free Content"; then
            echo "Error: GetFreeContent method failed"
            echo "Response: $response"
            docker logs grpc-content-server
            exit 1
          fi

          # Test gRPC through nginx proxy (L402 protected)
          echo "Testing gRPC through nginx proxy with L402 protection..."
          
          # First test without L402 header - should get 402
          echo "Testing gRPC endpoint without L402 header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -H "Content-Type: application/grpc" -H "grpc-timeout: 60S" -X POST http://0.0.0.0:8000/content.ContentService/GetProtectedContent)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: gRPC endpoint without L402 returned status $status_code, expected 402"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response for gRPC"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi

          # Flush Redis for gRPC test
          echo "Flushing Redis for gRPC test..."
          docker exec redis redis-cli flushall
          
          # Test with valid L402 credentials for gRPC
          echo "Testing gRPC endpoint with valid L402 credentials..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -H "Content-Type: application/grpc" -H "grpc-timeout: 60S" -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" -X POST http://0.0.0.0:8000/content.ContentService/GetProtectedContent)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: gRPC endpoint with valid L402 returned status $status_code, expected 200"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi

          echo "All gRPC tests completed successfully!"

      - name: Stop LNURL service
        run: |
          docker-compose -f docker-compose.yml stop nginx-lnurl

      - name: Start LND node, LND node receiver, cashu-mint and Tor
        run: |
          docker-compose -f docker-compose.yml up -d --no-deps bitcoind tor lndnode lndnode-receiver cashu-mint
          echo "waiting for 30 seconds..."
          sleep 30

      - name: Verify Bitcoin daemon Service, create wallet and fund lndnode and lndnode-receiver
        run: |
          #!/bin/bash

          wallet_name="my_wallet"
          echo "Using wallet: $wallet_name"

          # Check if wallet exists, create/load it
          if docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass listwallets | grep -q "\"$wallet_name\""; then
              echo "Wallet $wallet_name exists, loading..."
              docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass loadwallet "$wallet_name" 2>/dev/null
          else
              echo "Creating wallet $wallet_name..."
              docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass createwallet "$wallet_name"
          fi

          # Generate an address in this wallet
          fund_address=$(docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name getnewaddress)
          echo "Mining 101 blocks to $fund_address..."
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 101 "$fund_address" >> /dev/null

          echo "Sleeping 5 seconds..."
          sleep 5

          # ------- FUND LND NODE -------
          echo "Funding LND node..."

          # Print initial LND node balance
          initial_balance=$(docker exec lndnode lncli -n regtest walletbalance | jq -r '.confirmed_balance')
          echo "Initial LND node balance: $initial_balance sats"

          # Fund LND node
          lnd_addr=$(docker exec lndnode lncli -n regtest newaddress p2wkh | jq -r '.address')
          echo "Sending 1 BTC to LND node at $lnd_addr..."
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name sendtoaddress "$lnd_addr" 1

          # Mine 6 blocks to confirm funding
          new_addr=$(docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name getnewaddress)
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 6 "$new_addr"

          # Print final LND node balance
          final_balance=$(docker exec lndnode lncli -n regtest walletbalance | jq -r '.confirmed_balance')
          echo "Final LND node balance: $final_balance sats"

          echo "✅ LND node funded successfully!"

          # ------- FUND LND-receiver NODE -------
          echo "Funding LND-receiver node..."

          # Print initial LND-receiver node balance
          initial_balance=$(docker exec lndnode-receiver lncli --rpcserver=127.0.0.1:10010 -n regtest walletbalance | jq -r '.confirmed_balance')
          echo "Initial LND-receiver node balance: $initial_balance sats"

          # Fund LND-receiver node
          lnd_addr=$(docker exec lndnode-receiver lncli --rpcserver=127.0.0.1:10010 -n regtest newaddress p2wkh | jq -r '.address')
          echo "Sending 1 BTC to LND-receiver node at $lnd_addr..."
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name sendtoaddress "$lnd_addr" 1

          # Mine 6 blocks to confirm funding
          new_addr=$(docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name getnewaddress)
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 6 "$new_addr"

          echo "✅ LND-receiver node funded successfully!"

          # -------- CHANNEL (LND NODE RECEIVER - LND NODE) --------
          echo "Opening channel from LND-receiver node to LND node..."

          # Step 1: Get LND node pubkey
          LNDNODE_PUBKEY=$(docker exec lndnode lncli -n regtest getinfo | jq -r '.identity_pubkey')
          echo "LND node pubkey: $LNDNODE_PUBKEY"

          # Step 2: Connect receiver to LND node
          echo "Connecting LND-receiver to LND node..."
          docker exec lndnode-receiver lncli --network=regtest --rpcserver=127.0.0.1:10010 connect "$LNDNODE_PUBKEY"@lndnode:9735 || true

          # Step 3: Open channel from receiver to LND node
          echo "Opening channel from LND-receiver to LND node..."
          docker exec lndnode-receiver lncli --network=regtest --rpcserver=127.0.0.1:10010 openchannel --node_key="$LNDNODE_PUBKEY" --local_amt=1000000

          # Step 4: Mine 6 blocks to confirm channel
          echo "Mining 6 blocks to confirm channel..."
          docker exec bitcoind sh -c "bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 6 \$(bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name getnewaddress)"

          echo "✅ Channel lndnode-receiver to lndnode opened successfully!"

          # ------- CASHU SETUP -------
          echo 'Creating Cashu invoice...'

          docker exec cashu-mint sh -c "poetry run cashu invoice 25000 2>&1" > /tmp/cashu_output.txt &

          sleep 3

          CASHU_INVOICE=$(grep 'Invoice:' /tmp/cashu_output.txt | tail -1 | cut -d' ' -f2 || true)

          echo "Cashu invoice: $CASHU_INVOICE"
          rm /tmp/cashu_output.txt

          if [ -n "$CASHU_INVOICE" ]; then
            echo 'Paying Cashu mint invoice...'
            docker exec lndnode-receiver lncli --network=regtest --rpcserver=localhost:10010 sendpayment --pay_req="$CASHU_INVOICE" -f
            sleep 3
          else
            echo 'Could not create Cashu invoice, skipping token minting'
          fi

          # Get Cashu balance
          CASHU_BALANCE=$(docker exec cashu-mint sh -c "poetry run cashu balance" 2>/dev/null | grep 'Balance:' | awk '{print $2}' || echo '0')
          echo "Cashu user wallet balance: $CASHU_BALANCE sats"

          # ------ LIQUIDITY --------
          echo "Pushing liquidity from lndnode to lndnode-receiver..."
          INVOICE=$(docker exec lndnode lncli -n regtest addinvoice --amt=8000 | jq -r '.payment_request')
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 payinvoice --force "$INVOICE"
          sleep 3
          echo "✅ Liquidity pushed successfully!"

      - name: Extract Macaroon and Cert Paths
        run: |
          CONTAINER_NAME="lndnode"
          
          # Wait a bit more for LND to fully start
          echo "Checking if LND is ready..."
          for i in {1..30}; do
            if docker exec ${CONTAINER_NAME} lncli -n regtest getinfo > /dev/null 2>&1; then
              echo "LND is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Warning: LND may not be fully ready, but continuing..."
            fi
            sleep 2
          done
          
          # Define paths to the macaroon and certificate in the container
          MACAROON_PATH="/root/.lnd/data/chain/bitcoin/regtest/admin.macaroon"
          CERT_PATH="/root/.lnd/tls.cert"
          
          # Copy macaroon
          if docker exec ${CONTAINER_NAME} test -f "$MACAROON_PATH" 2>/dev/null; then
            docker cp ${CONTAINER_NAME}:$MACAROON_PATH ./admin.macaroon
            echo "✓ Extracted macaroon from $MACAROON_PATH"
          else
            echo "Error: Macaroon not found at $MACAROON_PATH"
            echo "Debug: Listing /root/.lnd structure:"
            docker exec ${CONTAINER_NAME} find /root/.lnd -type f 2>/dev/null | head -10 || true
            exit 1
          fi
          
          # Copy certificate
          if docker exec ${CONTAINER_NAME} test -f "$CERT_PATH" 2>/dev/null; then
            docker cp ${CONTAINER_NAME}:$CERT_PATH ./tls.cert
            echo "✓ Extracted certificate from $CERT_PATH"
          else
            echo "Error: Certificate not found at $CERT_PATH"
            echo "Debug: Listing /root/.lnd structure:"
            docker exec ${CONTAINER_NAME} ls -la /root/.lnd/ 2>/dev/null || true
            exit 1
          fi
          
          # Verify files were copied
          if [ -f "./admin.macaroon" ] && [ -f "./tls.cert" ]; then
            echo "✓ Successfully extracted macaroon and certificate"
            echo "MACAROON_PATH=./admin.macaroon" >> $GITHUB_ENV
            echo "CERT_PATH=./tls.cert" >> $GITHUB_ENV
          else
            echo "Error: Files were not copied successfully"
            exit 1
          fi

      - name: Wait for Tor to generate onion address
        run: |
          echo "Waiting for Tor to start and generate hidden service..."
          sleep 15
          
          # Based on docker-compose.yml Tor configuration:
          # HiddenServiceDir /var/lib/tor/hidden_service/
          # So the hostname file should be at: /var/lib/tor/hidden_service/hostname
          TOR_HOSTNAME_PATH="/var/lib/tor/hidden_service/hostname"
          
          max_attempts=30
          attempt=0
          ONION_ADDRESS=""
          
          while [ $attempt -lt $max_attempts ] && [ -z "$ONION_ADDRESS" ]; do
            # Check if Tor container is running
            if ! docker ps | grep -q tor; then
              echo "Tor container is not running"
              break
            fi
            
            # Check for hostname file at the configured path
            if docker exec tor test -f "$TOR_HOSTNAME_PATH" 2>/dev/null; then
              ONION_ADDRESS=$(docker exec tor cat "$TOR_HOSTNAME_PATH" 2>/dev/null | tr -d '\n\r')
              if [ -n "$ONION_ADDRESS" ]; then
                echo "✓ Found onion address: $ONION_ADDRESS"
                echo "LND_ONION_ADDRESS=$ONION_ADDRESS:10009" >> $GITHUB_ENV
                break
              fi
            fi
            
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for onion address..."
            if [ $attempt -eq 10 ]; then
              echo "Debug: Checking Tor directory structure:"
              docker exec tor ls -la /var/lib/tor/ 2>/dev/null || true
            fi
            sleep 2
          done
          
          if [ -z "$LND_ONION_ADDRESS" ]; then
            echo "Warning: Could not retrieve onion address after $max_attempts attempts"
            echo "Tor hidden service may take longer to generate, or may not be configured"
            echo "SOCKS5 proxy tests will be skipped"
          else
            echo "✓ Onion address retrieved: $LND_ONION_ADDRESS"
          fi

      - name: Test LND with SOCKS5 proxy (Tor connection)
        run: |
          if [ -n "$LND_ONION_ADDRESS" ]; then
            echo "Testing LND connection through Tor SOCKS5 proxy..."
            echo "Onion address: $LND_ONION_ADDRESS"
            echo "SOCKS5 proxy: 127.0.0.1:9050"
            cargo test --verbose || echo "SOCKS5 test completed (expected limitation noted)"
          else
            echo "Skipping SOCKS5 test - onion address not available"
          fi
        env:
          LN_CLIENT_TYPE: LND
          LND_ADDRESS: ${{ env.LND_ONION_ADDRESS }}
          SOCKS5_PROXY: 127.0.0.1:9050
          MACAROON_FILE_PATH: ${{ env.MACAROON_PATH }}
          CERT_FILE_PATH: ${{ env.CERT_PATH }}

      - name: Verify SOCKS5 proxy is accessible
        run: |
          echo "Testing SOCKS5 proxy connectivity..."
          # Test if Tor SOCKS5 proxy is accessible
          curl --socks5-hostname 127.0.0.1:9050 http://example.com > /dev/null 2>&1 && \
            echo "✓ SOCKS5 proxy is working" || \
            echo "⚠ SOCKS5 proxy test failed (may be expected in CI environment)"
          # Check if Tor is running
          docker ps | grep tor && echo "✓ Tor container is running" || echo "✗ Tor container not found"

      - name: Start cln services
        run: |
          docker-compose -f docker-compose.yml up -d --no-deps cln nginx-cln

      - name: Run Integration Tests - CLN
        run: |
          echo "Testing with CLN configuration..."
          sleep 15

          docker exec nginx-cln chmod 777 /root /root/.lightning /root/.lightning/regtest

          # Test free route
          echo "Testing free route..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Free route returned status $status_code, expected 200"
            docker logs nginx-cln
            exit 1
          fi

          # Flush Redis for CLN test
          echo "Flushing Redis for CLN test..."
          docker exec redis redis-cli flushall
          
          # Test with valid L402 credentials
          echo "Testing with valid L402 credentials..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Protected route with valid L402 returned status $status_code, expected 200"
            docker logs nginx-cln
            exit 1
          fi

          # Test with invalid preimage
          echo "Testing with invalid preimage..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:fbe9ac25c04e14b10177514e2d57b0e39224e70277ac1a2cd23c28e58cd4ea35" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with invalid preimage returned status $status_code, expected 401"
            docker logs nginx-cln
            exit 1
          fi

          # Test with macaroon without caveats
          echo "Testing with macaroon without caveats..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 AgEETFNBVALmAUr/gQMBARJNYWNhcm9vbklkZW50aWZpZXIB/4IAAQMBB1ZlcnNpb24BBgABC1BheW1lbnRIYXNoAf+EAAEHVG9rZW5JZAH/hgAAABT/gwEBAQRIYXNoAf+EAAEGAUAAABn/hQEBAQlbMzJddWludDgB/4YAAQYBQAAAa/+CAiD/pv/jOjY1/9oC/4z/tHb/qf/2Jf+d/4H/u/+YGHj/+/+O/8D/v/+P/8X/qRL/5v/x/4r/tkIBIA1Y/8j/pR3/0P+b/7cwWP+W/87/sD18GP//Hf/f/9Aj//NcBFs2/9VhNEUF/70AAAAGIDlR1jVm5IfEJgvuSQoJLqLg4FcW4Ib1vW8sbkRHdUWX:651505fae9ea341c770c6ebef207d8560d546eb3aee26985e584c15d1c987875" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with macaroon without caveats returned status $status_code, expected 401"
            docker logs nginx-cln
            exit 1
          fi

          # Test protected route without header
          echo "Testing protected route without header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 60 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-cln
            exit 1
          fi
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-cln
            exit 1
          fi

      - name: Stop CLN service
        run: |
          docker-compose -f docker-compose.yml stop nginx-cln

      # ========== BOLT12 Tests (runs while CLN is still up) ==========
      - name: Generate BOLT12 Offer and Start nginx-bolt12
        run: |
          echo "Generating BOLT12 Offer..."
          BOLT12_OFFER=$(docker exec cln lightning-cli --network=regtest offer any "L402 Access" | jq -r '.bolt12')
          echo "Generated BOLT12_OFFER: $BOLT12_OFFER"
          
          if [ -z "$BOLT12_OFFER" ] || [ "$BOLT12_OFFER" = "null" ]; then
            echo "Error: Failed to generate BOLT12 offer"
            docker logs cln
            exit 1
          fi
          
          echo "Starting nginx-bolt12 with BOLT12_OFFER..."
          export BOLT12_OFFER
          docker-compose -f docker-compose.yml up -d nginx-bolt12
          sleep 10
          # Set permissions on CLN socket (same as CLN tests)
          docker exec nginx-bolt12 chmod 777 /root /root/.lightning /root/.lightning/regtest

      - name: Run Integration Tests - BOLT12
        run: |
          echo "Testing with BOLT12 configuration..."
          
          # Test protected route without header
          echo "Testing protected route without header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://127.0.0.1:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-bolt12
            exit 1
          fi
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-bolt12
            exit 1
          fi

          # Extract and verify invoice (which might be an offer or bolt12 invoice)
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header"
            echo "$response"
            docker logs nginx-bolt12
            exit 1
          fi
          
          echo "Received Invoice/Offer: $invoice"
          
          # Check if it looks like a BOLT12 offer (lno), BOLT12 invoice (lni), or BOLT11 (lnbc/lntb)
          if [[ "$invoice" != lno* ]] && [[ "$invoice" != lni* ]] && [[ "$invoice" != lnbc* ]] && [[ "$invoice" != lntb* ]]; then
             echo "Error: Invoice does not look like BOLT12 offer/invoice or BOLT11 invoice"
             exit 1
          fi
          
          echo "✅ BOLT12 Integration test passed (Header verification)"

      - name: Stop nginx-bolt12
        run: docker-compose -f docker-compose.yml stop nginx-bolt12

      - name: Verify LND node
        run: |
          # Load the wallet created earlier
          wallet_name="my_wallet"
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass loadwallet "$wallet_name" 2>/dev/null || true

          identity_pubkey_lndnode=$(docker exec lndnode lncli -n regtest getinfo | jq -r '.identity_pubkey')
          echo "Pubkey: $identity_pubkey_lndnode"
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name -generate 5

          # Get node info for both lightning nodes
          echo "Getting CLN node info..."
          cln_pubkey=$(docker exec cln lightning-cli --network=regtest getinfo | jq -r '.id')
          echo "CLN pubkey: $cln_pubkey"

          echo "Getting LND node info..."
          lnd_pubkey=$(docker exec lndnode lncli -n regtest getinfo | jq -r '.identity_pubkey')
          echo "LND pubkey: $lnd_pubkey"

          # Generate a new address for LND node
          address=$(docker exec lndnode lncli -n regtest newaddress p2wkh | jq -r '.address')
          echo "Generated address for LND: $address"

          # Send 10 BTC to LND node
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name sendtoaddress "$address" 10
          
          # Generate blocks to confirm the transaction
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 6 "$address"

          # Wait for LND to sync after receiving funds
          echo "Waiting for LND to sync..."
          sleep 5

          # Connect nodes
          echo "Connecting LND to CLN..."
          docker exec lndnode lncli -n regtest connect $cln_pubkey@cln:9835

          # Open channel from LND to CLN (with retry)
          echo "Opening channel from LND to CLN..."
          for i in 1 2 3; do
            if docker exec lndnode lncli -n regtest openchannel $cln_pubkey 1000000; then
              echo "Channel opened successfully"
              break
            fi
            echo "Attempt $i failed, waiting 10 seconds..."
            sleep 10
          done

          # Generate blocks to confirm channel
          docker exec bitcoind bitcoin-cli -regtest -rpcuser=user -rpcpassword=pass -rpcwallet=$wallet_name generatetoaddress 6 "$address"

          echo "NWC_URI=$(docker exec cln lightning-cli --network=regtest nip47-create label=nwc-for-l402 budget_msat=0 | jq -r '.uri')" >> $GITHUB_ENV

      - name: Start NWC service
        run: |
          docker-compose -f docker-compose.yml up -d --no-deps nginx-nwc

      - name: Run Integration Tests - NWC
        run: |
          echo "Testing with NWC configuration..."
          sleep 20

          # Test free route
          echo "Testing free route..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Free route returned status $status_code, expected 200"
            docker logs nginx-nwc
            exit 1
          fi

          # Test protected route with timeout without header
          echo "Testing protected route with timeout without header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 60 -L http://0.0.0.0:8000/protected-timeout)
          status_code=$(echo "$response" | tail -n1)
          echo "status_code: $status_code"
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-nwc
            exit 1
          fi
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-nwc
            exit 1
          fi

          # Extract invoice from header
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header"
            echo "$response"
            docker logs nginx-nwc
            exit 1
          fi
          echo "invoice: $invoice"

          # Pay invoice using LND to get preimage
          echo "Paying invoice through LND..."
          payment_result=$(docker exec lndnode lncli -n regtest payinvoice -f $invoice 2>&1)
          echo "payment_result: $payment_result"
          
          # Wait a few seconds for payment to settle
          echo "Waiting for payment to settle..."
          sleep 5
          
          # Get payment result with preimage
          payment_result=$(docker exec lndnode lncli -n regtest listpayments | jq -r '.payments[-1]')
          payment_status=$(echo "$payment_result" | jq -r '.status')
          echo "payment_result: $payment_result"
          echo "payment_status: $payment_status"
          
          if [ "$payment_status" != "SUCCEEDED" ]; then
            echo "Error: Payment failed or timed out"
            docker logs nginx-nwc
            exit 1
          fi

          # Extract preimage from payment result
          preimage=$(echo "$payment_result" | jq -r '.payment_preimage')
          macaroon=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'macaroon="[^"]*"' | cut -d'"' -f2)

          # Wait for preimage to be registered in the system
          echo "Waiting for preimage registration..."
          sleep 5

          # Test with obtained preimage
          echo "Testing protected route with valid preimage..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 $macaroon:$preimage" http://0.0.0.0:8000/protected-timeout)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Protected route with valid preimage returned status $status_code, expected 200"
            docker logs nginx-nwc
            exit 1
          fi

          # Wait for macaroon to expire (10 seconds)
          echo "Waiting for macaroon to expire..."
          sleep 15

          # Test with expired macaroon
          echo "Testing protected route with expired macaroon..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 $macaroon:$preimage" http://0.0.0.0:8000/protected-timeout)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with expired macaroon returned status $status_code, expected 401"
            docker logs nginx-nwc
            exit 1
          fi

          # Test with invalid preimage
          echo "Testing with invalid preimage..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:fbe9ac25c04e14b10177514e2d57b0e39224e70277ac1a2cd23c28e58cd4ea35" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with invalid preimage returned status $status_code, expected 401"
            docker logs nginx-nwc
            exit 1
          fi

          # Test with macaroon without caveats
          echo "Testing with macaroon without caveats..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 AgEETFNBVALmAUr/gQMBARJNYWNhcm9vbklkZW50aWZpZXIB/4IAAQMBB1ZlcnNpb24BBgABC1BheW1lbnRIYXNoAf+EAAEHVG9rZW5JZAH/hgAAABT/gwEBAQRIYXNoAf+EAAEGAUAAABn/hQEBAQlbMzJddWludDgB/4YAAQYBQAAAa/+CAiD/pv/jOjY1/9oC/4z/tHb/qf/2Jf+d/4H/u/+YGHj/+/+O/8D/v/+P/8X/qRL/5v/x/4r/tkIBIA1Y/8j/pR3/0P+b/7cwWP+W/87/sD18GP//Hf/f/9Aj//NcBFs2/9VhNEUF/70AAAAGIDlR1jVm5IfEJgvuSQoJLqLg4FcW4Ib1vW8sbkRHdUWX:651505fae9ea341c770c6ebef207d8560d546eb3aee26985e584c15d1c987875" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with macaroon without caveats returned status $status_code, expected 401"
            docker logs nginx-nwc
            exit 1
          fi

      - name: Stop NWC service and CLN node
        run: |
          docker-compose -f docker-compose.yml stop nginx-nwc cln

      - name: Start nginx containers for LND
        env:
          CURRENCY: USD
          AMOUNT: 0.01
        run: |
          # Start the remaining services
          docker-compose -f docker-compose.yml up -d --no-deps nginx-lnd redis

      - name: Run Integration Tests - LND
        run: |
          docker ps -a
          echo "Testing with LND configuration..."
          sleep 15

          # Test free route
          echo "Testing free route..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Free route returned status $status_code, expected 200"
            docker logs nginx-lnd
            exit 1
          fi

          # Test protected route without header
          echo "Testing protected route without header..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-lnd
            exit 1
          fi
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Extract and verify invoice amount
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header"
            echo "$response"
            docker logs nginx-lnurl
            exit 1
          fi

          # Decode invoice and check amount
          decoded_amount=$(docker exec lndnode lncli -n regtest decodepayreq "$invoice" | jq -r '.num_msat')
          if [ "$decoded_amount" != "10000" ]; then
            echo "Error: Invoice amount is $decoded_amount msat, expected 10000 msat"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Test dynamic pricing by setting a new price in Redis
          echo "Setting dynamic price to 15000 msat..."
          docker exec redis redis-cli set /protected 15000

          # Test protected route to get new invoice with dynamic price
          echo "Testing protected route with dynamic price..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route with dynamic price returned status $status_code, expected 402"
            docker logs nginx-lnd
            exit 1
          fi

          # Extract and verify new invoice amount
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header for dynamic price"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Decode invoice and check dynamic amount
          decoded_amount=$(docker exec lndnode lncli -n regtest decodepayreq "$invoice" | jq -r '.num_msat')
          if [ "$decoded_amount" != "15000" ]; then
            echo "Error: Dynamic invoice amount is $decoded_amount msat, expected 15000 msat"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Reset price back to default
          echo "Resetting price back to default..."
          docker exec redis redis-cli del /protected

          # Test protected route to verify reset price
          echo "Testing protected route with reset price..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route with reset price returned status $status_code, expected 402"
            docker logs nginx-lnd
            exit 1
          fi

          # Extract and verify reset invoice amount
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header after reset"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Decode invoice and check reset amount
          decoded_amount=$(docker exec lndnode lncli -n regtest decodepayreq "$invoice" | jq -r '.num_msat')
          if [ "$decoded_amount" != "10000" ]; then
            echo "Error: Reset invoice amount is $decoded_amount msat, expected 10000 msat"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi

          # Flush Redis for LND test
          echo "Flushing Redis for LND test..."
          docker exec redis redis-cli flushall
          
          # Test with valid L402 credentials
          echo "Testing with valid L402 credentials..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Protected route with valid L402 returned status $status_code, expected 200"
            docker logs nginx-lnd
            exit 1
          fi

          # Test with invalid preimage
          echo "Testing with invalid preimage..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:fbe9ac25c04e14b10177514e2d57b0e39224e70277ac1a2cd23c28e58cd4ea35" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with invalid preimage returned status $status_code, expected 401"
            docker logs nginx-lnd
            exit 1
          fi

          # Test with macaroon without caveats
          echo "Testing with macaroon without caveats..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 AgEETFNBVALmAUr/gQMBARJNYWNhcm9vbklkZW50aWZpZXIB/4IAAQMBB1ZlcnNpb24BBgABC1BheW1lbnRIYXNoAf+EAAEHVG9rZW5JZAH/hgAAABT/gwEBAQRIYXNoAf+EAAEGAUAAABn/hQEBAQlbMzJddWludDgB/4YAAQYBQAAAa/+CAiD/pv/jOjY1/9oC/4z/tHb/qf/2Jf+d/4H/u/+YGHj/+/+O/8D/v/+P/8X/qRL/5v/x/4r/tkIBIA1Y/8j/pR3/0P+b/7cwWP+W/87/sD18GP//Hf/f/9Aj//NcBFs2/9VhNEUF/70AAAAGIDlR1jVm5IfEJgvuSQoJLqLg4FcW4Ib1vW8sbkRHdUWX:651505fae9ea341c770c6ebef207d8560d546eb3aee26985e584c15d1c987875" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with macaroon without caveats returned status $status_code, expected 401"
            docker logs nginx-lnd
            exit 1
          fi

          # Test Cashu eCash support
          echo "Testing Cashu eCash support..."

          # Ensure the Cashu database has proper permissions
          echo "Setting up Cashu database permissions..."
          docker exec nginx-lnd chmod 770 /app/data
          docker exec nginx-lnd chmod 660 /app/data/cashu_tokens.db
          echo "Cashu database permissions set successfully"
          
          # Check mint logs
          docker logs cashu-mint
          
          # Execute cashu commands inside the mint container using poetry run
          echo "Executing cashu commands inside the mint container..."
          
          # Check wallet info
          echo "Checking wallet info..."
          docker exec cashu-mint poetry run cashu info
          
          # Check initial balance
          echo "Checking initial balance..."
          docker exec cashu-mint poetry run cashu balance
          
          # Check balance after minting
          echo "Checking balance after minting..."
          docker exec cashu-mint poetry run cashu balance
          
          # Get token from wallet
          echo "Retrieving token from wallet..."
          CASHU_TOKEN=$(docker exec cashu-mint poetry run cashu send 10)
          
          echo "Cashu token: $CASHU_TOKEN"

          sleep 5
          
          # Test protected route with Cashu token
          echo "Testing protected route with Cashu token..."
          max_retries=3
          retry_count=0
          status_code=0
          
          while [ $retry_count -lt $max_retries ] && [ "$status_code" -ne 200 ]; do
            echo "Attempt $(($retry_count + 1)) of $max_retries..."
            response=$(curl -v -s -i -w "\n%{http_code}" --max-time 60 -L -H "Authorization: Cashu $CASHU_TOKEN" http://0.0.0.0:8000/protected)
            status_code=$(echo "$response" | tail -n1)
            
            if [ "$status_code" -ne 200 ]; then
              if echo "$response" | grep -q "401 Unauthorized"; then
                echo "Pool connection timed out, retrying..."
                sleep 5
                retry_count=$((retry_count + 1))
              else
                break
              fi
            fi
          done
          
          # The token should be accepted if the verification logic is working
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Protected route with Cashu token returned unexpected status $status_code"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi
          
          # Test with invalid Cashu token (insufficient amount)
          echo "Testing with invalid Cashu token (insufficient amount)..."
          
          INVALID_CASHU_TOKEN=$(docker exec cashu-mint poetry run cashu send 1)

          sleep 5
          
          # Test with the invalid token
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $INVALID_CASHU_TOKEN" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          
          # This should fail verification due to insufficient amount
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with invalid Cashu token returned status $status_code, expected 401"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi
          
          # Test with malformed Cashu token
          echo "Testing with malformed Cashu token..."
          
          # Create a malformed token
          MALFORMED_CASHU_TOKEN='{
            "token": [
              {
                "mint": "http://cashu-mint:3338",
                "proofs": []
              }
            ]
          }'
          
          # Encode the malformed token
          ENCODED_MALFORMED_TOKEN=$(echo -n "$MALFORMED_CASHU_TOKEN" | base64 -w 0)

          sleep 5
          
          # Test with the malformed token
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $ENCODED_MALFORMED_TOKEN" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          
          # This should fail verification due to empty proofs
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with malformed Cashu token returned status $status_code, expected 401"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi
          
          # Test whitelisted mints functionality
          echo "Testing whitelisted mints functionality..."
          
          # Test with token from non-whitelisted mint
          echo "Testing with token from non-whitelisted mint (https://nofees.testnut.cashu.space)..."
          
          # Create a token with a non-whitelisted mint URL
          NON_WHITELISTED_TOKEN='{
            "token": [
              {
                "mint": "https://nofees.testnut.cashu.space",
                "proofs": [
                  {
                    "id": "test-proof",
                    "amount": 10,
                    "secret": "test-secret",
                    "C": "test-commitment"
                  }
                ]
              }
            ]
          }'
          
          # Encode the non-whitelisted token
          ENCODED_NON_WHITELISTED_TOKEN=$(echo -n "$NON_WHITELISTED_TOKEN" | base64 -w 0)

          sleep 5
          
          # Test with the non-whitelisted token
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $ENCODED_NON_WHITELISTED_TOKEN" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          
          # This should fail verification due to non-whitelisted mint
          if [ "$status_code" -ne 401 ]; then
            echo "Error: Protected route with non-whitelisted Cashu token returned status $status_code, expected 401"
            echo "$response"
            docker logs nginx-lnd
            exit 1
          fi
          
          echo "✅ Non-whitelisted mint token (https://nofees.testnut.cashu.space) correctly rejected!"
          
          echo "All Cashu eCash tests completed successfully!"
          docker logs nginx-lnd

      - name: Run Integration test - Redis Replay Attack Prevention
        run: |
          echo "🔒 Testing Redis replay attack prevention for L402 preimages and Cashu tokens..."
          
          # Flush Redis to start clean
          docker exec redis redis-cli flushall
          
          # ========== TEST 1: L402 Preimage Replay Attack Prevention ==========
          echo "Testing L402 preimage replay attack prevention..."
          
          # First request with valid L402 credentials should succeed
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "❌ Error: First request with valid L402 preimage returned status $status_code, expected 200"
            docker logs nginx-lnurl
            exit 1
          fi
          echo "✅ First request with valid L402 preimage succeeded"
          
          # Wait a moment for Redis to store the preimage
          sleep 2
          
          # Check Redis for stored preimage
          PREIMAGE_KEYS=$(docker exec redis redis-cli keys "l402:preimage:*" 2>/dev/null | wc -l)
          echo "Found $PREIMAGE_KEYS preimage entries in Redis"
          if [ "$PREIMAGE_KEYS" -lt 1 ]; then
            echo "❌ Error: Preimage was not stored in Redis"
            exit 1
          fi
          echo "✅ Preimage stored in Redis successfully"
          
          # Second request with SAME preimage should fail (replay attack)
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -H "Authorization: L402 MDAxMmxvY2F0aW9uIEw0MDIKMDAzMGlkZW50aWZpZXIgM460twjJAuVrQN-u5JPUZ0aKNWevybkbveRc2DeF2ZAKMDAyMWNpZCBSZXF1ZXN0UGF0aCA9IC9wcm90ZWN0ZWQKMDAyZnNpZ25hdHVyZSCwR6G2lDj1thda81BPwQuo73_shURzPf1XOwuejNLwVwo=:e582fba50ca50a9a262cbb92fc38617ce0a2413ef1dd4c7062cbaef22b33a404" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "❌ Error: Replay attack with same L402 preimage returned status $status_code, expected 401"
            docker logs nginx-lnurl
            exit 1
          fi
          echo "✅ L402 preimage replay attack prevented successfully!"
          
          # ========== TEST 2: Cashu Token Replay Attack Prevention ==========
          echo "Testing Cashu token replay attack prevention..."
          
          # Create a Cashu token
          CASHU_TOKEN=$(docker exec cashu-mint poetry run cashu send 10)
          echo "Created Cashu token: ${CASHU_TOKEN:0:50}..."
          
          # First request with Cashu token should succeed
          response=$(curl -s -w "\n%{http_code}" --max-time 60 -L -H "Authorization: Cashu $CASHU_TOKEN" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "❌ Error: First request with Cashu token returned status $status_code, expected 200"
            docker logs nginx-lnd
            exit 1
          fi
          echo "✅ First request with Cashu token succeeded"
          
          # Wait a moment for Redis to store the token
          sleep 2
          
          # Check Redis for stored Cashu token
          CASHU_KEYS=$(docker exec redis redis-cli keys "l402:cashu_token:*" 2>/dev/null | wc -l)
          echo "Found $CASHU_KEYS Cashu token entries in Redis"
          if [ "$CASHU_KEYS" -lt 1 ]; then
            echo "❌ Error: Cashu token was not stored in Redis"
            exit 1
          fi
          echo "✅ Cashu token stored in Redis successfully"
          
          # Second request with SAME Cashu token should fail (replay attack)
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $CASHU_TOKEN" http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 401 ]; then
            echo "❌ Error: Replay attack with same Cashu token returned status $status_code, expected 401"
            docker logs nginx-lnd
            exit 1
          fi
          echo "✅ Cashu token replay attack prevented successfully!"
          
          # ========== SUMMARY ==========
          echo "📊 Redis replay attack prevention summary:"
          echo "  - L402 preimage entries: $PREIMAGE_KEYS"
          echo "  - Cashu token entries: $CASHU_KEYS"
          
          # Show sample Redis keys
          echo "Sample Redis keys:"
          docker exec redis redis-cli keys "l402:*" | head -5
          
          echo "✅ All Redis replay attack prevention tests passed!"
        env:
          CASHU_WHITELISTED_MINTS: http://cashu-mint:3338
          CASHU_WALLET_SECRET: test_wallet_secret_for_ci

      - name: Run Integration test - Cashu redemption on Lightning
        run: |
          # Capture initial channel balance (not wallet balance, since Lightning payments affect channels)
          INITIAL_RECEIVER_CHANNEL=$(docker exec lndnode-receiver lncli --rpcserver=127.0.0.1:10010 -n regtest channelbalance)
          echo "Initial LND-receiver Channel Balance: $INITIAL_RECEIVER_CHANNEL"

          INITIAL_RECEIVER_LOCAL_BALANCE=$(echo $INITIAL_RECEIVER_CHANNEL | jq -r '.local_balance.sat')
          echo "Initial LND-receiver Local Balance: $INITIAL_RECEIVER_LOCAL_BALANCE sats"

          INITIAL_LND_CHANNEL=$(docker exec lndnode lncli -n regtest channelbalance)
          echo "Initial LND Channel Balance: $INITIAL_LND_CHANNEL"

          INITIAL_LND_LOCAL_BALANCE=$(echo $INITIAL_LND_CHANNEL | jq -r '.local_balance.sat')
          echo "Initial LND Local Balance: $INITIAL_LND_LOCAL_BALANCE sats"

          echo "initial channel balance: lndnode"
          docker exec lndnode lncli -n regtest channelbalance

          echo "initial channel balance: lndnode-receiver"
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 channelbalance

          echo "initial channels info: lndnode"
          docker exec lndnode lncli -n regtest listchannels

          echo "initial channels info: lndnode-receiver"
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 listchannels

          echo "Cashu current balance"
          docker exec cashu-mint poetry run cashu balance

          echo "Running Cashu redemption on Lightning test..."
          cashu_token=$(docker exec cashu-mint poetry run cashu send 100)
          echo "Cashu Token of amount 100: $cashu_token"

          # access protected nginx-lnd route with cashu token
          response=$(curl -s -w "\n%{http_code}" --max-time 60 -L -H "Authorization: Cashu $cashu_token" http://0.0.0.0:8000/protected)

          if [ "$(echo "$response" | tail -n1)" -ne 200 ]; then
            echo "Error: unable to access protected route with Cashu token with response $(echo "$response" | tail -n1)"
            docker logs nginx-lnd
            exit 1
          fi

          echo "Cashu token consumed successfully to access protected route."

          REDEMPTION_INTERVAL=$(docker exec nginx-lnd env | grep CASHU_REDEMPTION_INTERVAL_SECS | cut -d'=' -f2 || echo "not_set")
          WAIT_TIME=$((REDEMPTION_INTERVAL + 30))

          echo "Waiting for $WAIT_TIME seconds to allow redemption process to complete..."
          sleep $WAIT_TIME

          # Capture final channel balance (Lightning payments affect channel balance, not wallet balance)
          FINAL_RECEIVER_CHANNEL=$(docker exec lndnode-receiver lncli --rpcserver=127.0.0.1:10010 -n regtest channelbalance)
          echo "FINAL LND-receiver Channel Balance: $FINAL_RECEIVER_CHANNEL"

          FINAL_RECEIVER_LOCAL_BALANCE=$(echo $FINAL_RECEIVER_CHANNEL | jq -r '.local_balance.sat')
          echo "FINAL LND-receiver Local Balance: $FINAL_RECEIVER_LOCAL_BALANCE sats"

          FINAL_LND_CHANNEL=$(docker exec lndnode lncli -n regtest channelbalance)
          echo "FINAL LND Channel Balance: $FINAL_LND_CHANNEL"

          FINAL_LND_LOCAL_BALANCE=$(echo $FINAL_LND_CHANNEL | jq -r '.local_balance.sat')
          echo "FINAL LND Local Balance: $FINAL_LND_LOCAL_BALANCE sats"

          BALANCE_RECEIVER_DIFFERENCE=$((FINAL_RECEIVER_LOCAL_BALANCE - INITIAL_RECEIVER_LOCAL_BALANCE))
          echo "Channel Balance RECEIVER Difference: $BALANCE_RECEIVER_DIFFERENCE sats"

          BALANCE_LND_DIFFERENCE=$((FINAL_LND_LOCAL_BALANCE - INITIAL_LND_LOCAL_BALANCE))
          echo "Channel Balance Difference (LND): $BALANCE_LND_DIFFERENCE sats"

          echo "final channel balance: lndnode"
          docker exec lndnode lncli -n regtest channelbalance

          echo "final channel balance: lndnode-receiver"
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 channelbalance

          echo "final channels info: lndnode"
          docker exec lndnode lncli -n regtest listchannels

          echo "final channels info: lndnode-receiver"
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 listchannels

          echo "invoices by lnd node"
          docker exec lndnode lncli -n regtest listinvoices | tail -20

          echo "invoices by lnd-receiver node"
          docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 listinvoices | tail -20

          if [ "$BALANCE_RECEIVER_DIFFERENCE" -gt 0 ]; then
            echo "✅ LND-receiver channel balance increased by $BALANCE_RECEIVER_DIFFERENCE sats from Cashu token redemption"
          else
            echo "❌ No redemption activity detected - channel balance did not increase"

            echo "Payments by lnd node"
            docker exec lndnode lncli -n regtest listpayments

            echo "Payments by lnd-receiver node"
            docker exec lndnode-receiver lncli -n regtest --rpcserver=127.0.0.1:10010 listpayments

            echo "========== NGINX-LND LOGS BEGIN ==============="
            docker logs nginx-lnd
            echo "============ NGINX-LND LOGS END ================"

            echo "========== CASHU MINT LOGS BEGIN ==============="
            docker logs cashu-mint
            echo "============ CASHU MINT LOGS END ================"

            exit 1
          fi

          echo "✅ Cashu redemption on Lightning integration tests completed!"

      - name: Verify Dynamic Fee Discovery Feature
        run: |
          echo "════════════════════════════════════════════════════"
          echo "   Testing Dynamic Fee Discovery Feature"
          echo "════════════════════════════════════════════════════"
          echo ""
          
          echo "[1/3] Checking if feature was triggered during redemption..."
          
          # Check logs for the feature trigger
          if docker logs nginx-lnd 2>&1 | grep -q "Fetching Mint Info for dynamic fee discovery"; then
            echo "✅ Dynamic fee discovery feature triggered successfully"
            echo ""
            
            echo "[2/3] Extracting fee discovery results from logs..."
            docker logs nginx-lnd 2>&1 | grep -E "(Fetching Mint Info|Found dynamic fee|Found dynamic min fee|Using default fees)" | tail -10
            echo ""
            
            echo "[3/3] Verifying fee discovery outcome..."
            # Check if fees were discovered or defaults used (both are valid outcomes)
            if docker logs nginx-lnd 2>&1 | grep -q "Found dynamic fee:.*ppk"; then
              echo "✅ SUCCESS: Dynamic fees discovered from mint's NUT-08 endpoint"
              
              # Extract and display the discovered fee
              FEE_LINE=$(docker logs nginx-lnd 2>&1 | grep "Found dynamic fee:.*ppk" | tail -1)
              echo "   $FEE_LINE"
              
              # Check for minimum fee too
              if docker logs nginx-lnd 2>&1 | grep -q "Found dynamic min fee:"; then
                MIN_FEE_LINE=$(docker logs nginx-lnd 2>&1 | grep "Found dynamic min fee:" | tail -1)
                echo "   $MIN_FEE_LINE"
              fi
            elif docker logs nginx-lnd 2>&1 | grep -q "Using default fees"; then
              echo "✅ SUCCESS: Mint didn't provide NUT-08 fees, using defaults (expected behavior)"
            elif docker logs nginx-lnd 2>&1 | grep -q "NUT-08 config not found"; then
              echo "✅ SUCCESS: Mint response didn't contain NUT-08, using defaults (expected behavior)"
            else
              echo "⚠️  WARNING: Fee discovery ran but outcome unclear. Check logs below:"
              docker logs nginx-lnd 2>&1 | grep -i "mint info" | tail -10
            fi
            
            echo ""
            echo "════════════════════════════════════════════════════"
            echo "   ✅ Dynamic Fee Discovery Test PASSED"
            echo "════════════════════════════════════════════════════"
          else
            echo "❌ FAILED: Dynamic fee discovery feature did NOT trigger"
            echo ""
            echo "Expected to find log message: 'Fetching Mint Info for dynamic fee discovery'"
            echo ""
            echo "Recent nginx-lnd logs (last 100 lines):"
            docker logs nginx-lnd 2>&1 | tail -100
            echo ""
            echo "════════════════════════════════════════════════════"
            echo "   ❌ Dynamic Fee Discovery Test FAILED"
            echo "════════════════════════════════════════════════════"
            exit 1
          fi

      - name: Stop nginx-lnd and start nginx-lnurl
        env: 
          CASHU_WHITELISTED_MINTS: http://cashu-mint:3338
          CASHU_WALLET_SECRET: test_wallet_secret_for_ci
          LNURL_ADDRESS: hello@getalby.com
        run: |
          echo "Stopping nginx-lnd and starting nginx-lnurl for multi-tenant LNURL mode..."
          docker-compose -f docker-compose.yml stop nginx-lnd
          docker-compose -f docker-compose.yml up -d nginx-lnurl
          sleep 15

      - name: Run Integration Tests - Multi-tenant LNURL Cashu Redemption
        run: |
          echo "🏢 Testing Multi-tenant LNURL Cashu Redemption with 2 tenants..."

          # Flush Redis for clean test
          echo "Setting up Redis for multi-tenant testing..."
          docker exec redis redis-cli flushall

          # Create Cashu tokens for 2 tenants
          echo "Creating Cashu tokens for 2-tenant multi-tenant redemption..."

          # Create token 1 for tenant1 (amount: 50 sats) - maps to hello@getalby.com (nginx.conf)
          TOKEN1=$(docker exec cashu-mint poetry run cashu send 50)
          echo "Token1 for tenant1 (50 sats): $TOKEN1"

          # Create token 2 for tenant2 (amount: 30 sats) - maps to bumi@getalby.com (nginx.conf)
          TOKEN2=$(docker exec cashu-mint poetry run cashu send 30)
          echo "Token2 for tenant2 (30 sats): $TOKEN2"

          sleep 5

          # ========== TEST ACCESSING TENANT-SPECIFIC ROUTES ==========
          echo "Testing multi-tenant token redemption with 2 different LNURL addresses..."

          # Access tenant1 route - should map to hello@getalby.com (from nginx.conf)
          echo "Accessing tenant1 route (hello@getalby.com)..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $TOKEN1" http://0.0.0.0:8000/tenant1)
          if [ "$(echo "$response" | tail -n1)" -ne 200 ]; then
            echo "Error: Failed to access tenant1 route with Token1"
            docker logs nginx-lnurl | tail -50
            exit 1
          fi
          echo "✅ Token1 accepted and mapped to tenant1 (hello@getalby.com)"

          # Access tenant2 route - should map to bumi@getalby.com (from nginx.conf)
          echo "Accessing tenant2 route (bumi@getalby.com)..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L -H "Authorization: Cashu $TOKEN2" http://0.0.0.0:8000/tenant2)
          if [ "$(echo "$response" | tail -n1)" -ne 200 ]; then
            echo "Error: Failed to access tenant2 route with Token2"
            docker logs nginx-lnurl | tail -50
            exit 1
          fi
          echo "✅ Token2 accepted and mapped to tenant2 (bumi@getalby.com)"

          # ========== VERIFY REDIS PROOF-TO-LNURL MAPPINGS ==========
          echo "Checking Redis for proof-to-lnurl mappings..."
          sleep 2
          REDIS_KEYS=$(docker exec redis redis-cli keys "cashu:proof_lnurl:*" 2>/dev/null | wc -l)
          echo "Found $REDIS_KEYS proof-to-lnurl mappings in Redis"

          if [ "$REDIS_KEYS" -gt 0 ]; then
            echo "✅ Multi-tenant proof mappings created in Redis"
          else
            echo "❌ No proof mappings found in Redis"
            exit 1
          fi

          echo "✅ Multi-tenant LNURL Cashu Redemption integration test completed with 2 tenants!"

      - name: Stop nginx-lnurl and start litd
        run: |
          echo "Stopping nginx-lnurl and starting litd (Lightning Terminal)..."
          docker-compose -f docker-compose.yml stop nginx-lnurl
          docker-compose -f docker-compose.yml up -d litd
          sleep 20
          echo "Waiting for litd to fully start..."
          
          # Check if litd is responding
          max_attempts=30
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if docker exec litd wget -q -O- http://localhost:8443 > /dev/null 2>&1; then
              echo "✓ litd is responding"
              break
            fi
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for litd..."
            sleep 2
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "Warning: litd may not be fully ready, but continuing..."
            docker logs litd
          fi

      - name: Generate LNC Pairing Phrase
        run: |
          echo "Generating LNC pairing phrase..."
          
          # Wait for litd to be fully ready
          sleep 10
          
          max_attempts=10
          attempt=0
          PAIRING_PHRASE=""
          
          while [ $attempt -lt $max_attempts ] && [ -z "$PAIRING_PHRASE" ]; do
            echo "Attempt $attempt/$max_attempts: Creating LNC session..."
            
            SESSION_OUTPUT=$(docker exec litd litcli --network=regtest sessions add --label="ci_test" --type=admin 2>&1 || true)
            
            echo "Debug: Session output:"
            echo "$SESSION_OUTPUT"
            
            if echo "$SESSION_OUTPUT" | grep -q "pairing_secret_mnemonic"; then
              # Extract the full mnemonic - it should be the value of pairing_secret_mnemonic field
              # The output is JSON-like, so we extract everything between the quotes after pairing_secret_mnemonic
              PAIRING_PHRASE=$(echo "$SESSION_OUTPUT" | grep "pairing_secret_mnemonic" | sed 's/.*"pairing_secret_mnemonic"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | tr -d '\n')
              
              # Count words to verify we got the full phrase
              WORD_COUNT=$(echo "$PAIRING_PHRASE" | wc -w)
              echo "Debug: Extracted phrase with $WORD_COUNT words"
              
              if [ "$WORD_COUNT" -eq 10 ] && [ -n "$PAIRING_PHRASE" ]; then
                echo "✓ Generated pairing phrase with 10 words"
                echo "LNC_PAIRING_PHRASE=$PAIRING_PHRASE" >> $GITHUB_ENV
                break
              else
                echo "Warning: Got $WORD_COUNT words instead of 10, retrying..."
                PAIRING_PHRASE=""
              fi
            fi
            
            attempt=$((attempt + 1))
            if [ $attempt -lt $max_attempts ]; then
              sleep 3
            fi
          done
          
          if [ -z "$PAIRING_PHRASE" ]; then
            echo "Error: Could not generate LNC pairing phrase after $max_attempts attempts"
            echo "Checking litd logs:"
            docker logs litd | tail -100
            exit 1
          fi
          
          echo "✓ LNC pairing phrase generated successfully"
          echo "Pairing phrase: ${PAIRING_PHRASE:0:50}..."

      - name: Start nginx-lnc
        run: |
          echo "Starting nginx-lnc with LNC configuration..."
          docker-compose -f docker-compose.yml up -d nginx-lnc
          sleep 15

      - name: Run Integration Tests - LNC
        run: |
          echo "Testing with LNC (Lightning Node Connect) configuration..."
          
          # Test free route
          echo "Testing free route..."
          response=$(curl -s -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 200 ]; then
            echo "Error: Free route returned status $status_code, expected 200"
            docker logs nginx-lnc
            exit 1
          fi
          echo "✅ Free route test passed"

          # Test protected route without header - should return 402 with invoice
          echo "Testing protected route without header (LNC invoice generation)..."
          response=$(curl -s -i -w "\n%{http_code}" --max-time 30 -L http://0.0.0.0:8000/protected)
          status_code=$(echo "$response" | tail -n1)
          if [ "$status_code" -ne 402 ]; then
            echo "Error: Protected route without header returned status $status_code, expected 402"
            docker logs nginx-lnc
            exit 1
          fi
          echo "✅ Protected route returned 402 Payment Required"
          
          # Check if WWW-Authenticate header is present
          if ! echo "$response" | grep -q 'WWW-Authenticate: L402 macaroon='; then
            echo "Error: WWW-Authenticate header is missing in the 402 response"
            echo "$response"
            docker logs nginx-lnc
            exit 1
          fi
          echo "✅ WWW-Authenticate header present"

          # Extract and validate invoice from header
          invoice=$(echo "$response" | grep -i "WWW-Authenticate: L402" | grep -o 'invoice="[^"]*"' | cut -d'"' -f2)
          if [ -z "$invoice" ]; then
            echo "Error: No invoice found in WWW-Authenticate header"
            echo "$response"
            docker logs nginx-lnc
            exit 1
          fi
          echo "✅ Invoice extracted: ${invoice:0:50}..."

          # Validate invoice format (should start with lnbc for mainnet or lnbcrt for regtest)
          if [[ "$invoice" =~ ^lnbc ]]; then
            echo "✅ Invoice has valid BOLT11 format (lnbc prefix)"
          elif [[ "$invoice" =~ ^lntb ]]; then
            echo "✅ Invoice has valid BOLT11 testnet format (lntb prefix)"
          elif [[ "$invoice" =~ ^lnbcrt ]]; then
            echo "✅ Invoice has valid BOLT11 regtest format (lnbcrt prefix)"
          else
            echo "Error: Invoice does not have valid BOLT11 format"
            echo "Invoice: $invoice"
            exit 1
          fi

          # Decode invoice to verify it was generated correctly
          echo "Decoding invoice to verify structure..."
          decoded=$(docker exec lndnode lncli -n regtest decodepayreq "$invoice" 2>&1)
          if echo "$decoded" | grep -q "num_msat"; then
            amount=$(echo "$decoded" | jq -r '.num_msat' 2>/dev/null || echo "unknown")
            echo "✅ Invoice decoded successfully (amount: $amount msat)"
          else
            echo "Warning: Could not decode invoice, but invoice was generated"
            echo "Decoded output: $decoded"
          fi

          echo "✅ LNC invoice generation test completed successfully!"
          echo "✅ LNC integration with Lightning Terminal verified!"

      - name: Stop nginx-lnc and litd
        run: |
          docker-compose -f docker-compose.yml stop nginx-lnc litd

      - name: Publish .so file
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          tar -czf ngx_l402-${VERSION}.tar.gz target/release/libngx_l402_lib.so
          gh release create ${GITHUB_REF#refs/tags/} ngx_l402-${VERSION}.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}